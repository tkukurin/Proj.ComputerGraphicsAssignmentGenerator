<html>

<head>
<title>WebGL Up And Running &mdash; Example 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script> <!-- Get the latest version of the Three.js library. -->
<script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
<!-- <script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/OrthographicTrackballControls.js"></script> -->

<script src="./project1/modifiedOrthoControls.js"></script>
<script src="./helpers.js"></script>

</head>

<body>
    
<script type="text/javascript">

    function getPoint(A, materialProperties) {
        const geometry = new THREE.Geometry();
        const material = new THREE.PointsMaterial(materialProperties);

        const v1 = new THREE.Vector3(A.x, A.y, 0);
        geometry.vertices.push(v1);

        return new THREE.Points(geometry, material);
    }

    function getLine(A, B, materialProperties) {
        const geometry = new THREE.Geometry();
        const material = new THREE.LineBasicMaterial(materialProperties);

        const v1 = new THREE.Vector3(A.x, A.y, 0);
        const v2 = new THREE.Vector3(B.x, B.y, 0);
        geometry.vertices.push(v1);
        geometry.vertices.push(v2);

        return new THREE.LineSegments(geometry, material);
    }

    function getWireframe(geometry, materialProperties) {        
        const geom = new THREE.EdgesGeometry(geometry);
        const mat = new THREE.LineBasicMaterial(materialProperties);

        return new THREE.LineSegments(geom, mat);
    }

    function getTriangleWireframe(A, B, C) {
        const geometry = new THREE.Geometry();
        const v1 = new THREE.Vector3(A.x, A.y, 0);
        const v2 = new THREE.Vector3(B.x, B.y, 0);
        const v3 = new THREE.Vector3(C.x, C.y, 0);

        geometry.vertices.push(v1);
        geometry.vertices.push(v2);
        geometry.vertices.push(v3);
        geometry.faces.push( new THREE.Face3( 0, 1, 2 ) );

        return getWireframe(geometry, { color: 0xff0000, linewidth: 2 });
    }

    function getSquarePoint(loc, material) {
        var geometry = new THREE.CircleGeometry( 0.25, 10 );
        geometry.translate(loc.x, loc.y, 0);
        geometry.computeFaceNormals();

        var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
        var cube = new THREE.Mesh( geometry, material );
        return cube;
    }

    function getSquareWireframe(A, B, C, D) {
        const geometry = new THREE.Geometry();
        const v1 = new THREE.Vector3(A.x, A.y,0);
        const v2 = new THREE.Vector3(B.x, B.y,0);
        const v3 = new THREE.Vector3(C.x, C.y,0);
        const v4 = new THREE.Vector3(D.x, D.y,0);

        geometry.vertices.push(v1);
        geometry.vertices.push(v2);
        geometry.vertices.push(v3);
        geometry.vertices.push(v4);

        geometry.faces.push(new THREE.Face3(0, 1, 2));
        geometry.faces.push(new THREE.Face3(0, 3, 2));

        return getWireframe(geometry, { color: 0xff0000, linewidth: 2 });
    }

    function getTriangle(A, B, C) {
        var geom = new THREE.Geometry();
        var v1 = new THREE.Vector3(A.x, A.y,0);
        var v2 = new THREE.Vector3(B.x, B.y,0);
        var v3 = new THREE.Vector3(C.x, C.y,0);

        geom.vertices.push(v1);
        geom.vertices.push(v2);
        geom.vertices.push(v3);

        geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
        geom.computeFaceNormals();

        return new THREE.Mesh( geom, new THREE.MeshNormalMaterial() );
    }

    function buildAxis( src, dst, colorHex, dashed ) {
        var geom = new THREE.Geometry(),
            mat;

        if(dashed) {
                mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
        } else {
                mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
        }

        geom.vertices.push( src.clone() );
        geom.vertices.push( dst.clone() );
        geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

        var axis = new THREE.Line( geom, mat, THREE.LineSegments );

        return axis;
    }

    function buildAxes( length ) {
        var axes = new THREE.Object3D();

        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    
        return axes;
    }

    function NumeratedGridHelper( size, divisions, color1, color2 ) {

        size = size || 10;
        divisions = divisions || 10;
        color1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );
        color2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );

        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;

        var vertices = [], colors = [];

        for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

            vertices.push( - halfSize, 0, k, halfSize, 0, k );
            vertices.push( k, 0, - halfSize, k, 0, halfSize );

            var color = i === center ? color1 : color2;

            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            
        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

        var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

        THREE.LineSegments.call( this, geometry, material );
    }

    NumeratedGridHelper.prototype = Object.create( THREE.LineSegments.prototype );
    NumeratedGridHelper.prototype.constructor = NumeratedGridHelper;


    var canUpdate = true;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    document.body.appendChild(renderer.domElement);
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( 0xeeeeee, 1.0 );

    const scene = new THREE.Scene();
    //var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    /*const camera = new THREE.OrthographicCamera(-window.innerWidth / 50, 
                                                window.innerWidth / 50, 
                                                -window.innerHeight / 50,
                                                window.innerHeight / 50); // */ //new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );
    const viewportMaxAxis = 30;
    const camera = new THREE.OrthographicCamera(-viewportMaxAxis, 
                                                viewportMaxAxis, 
                                                (window.innerHeight / window.innerWidth) * viewportMaxAxis,
                                                -(window.innerHeight / window.innerWidth)* viewportMaxAxis);
    camera.position.set( 0, 0, 20 );
    var lookVector = new THREE.Vector3( 0, 0, 0 );
    camera.lookAt( lookVector );

    const controls = new THREE.OrthographicTrackballControls(camera, {x: viewportMaxAxis, y: viewportMaxAxis});
    var axis;
    var gridHelper;
    //const worldCoordinateHelper = new WorldCoordinateHelper(camera, {width: this.window.innerWidth, height: this.window.innerHeight}, new THREE.Raycaster());
    // canvas.getBoundingClientRect()
    const worldCoordinateHelper = new WorldCoordinateHelper(camera, renderer.context.canvas.getBoundingClientRect(), new THREE.Raycaster());
    var pt;
    var outline;

    document.addEventListener('mousemove', (e) => {
        if(axis)
            scene.remove(axis);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0);
        const window = renderer.context.canvas;

        mouse.x = ( event.clientX / window.width ) * 2 - 1;
        mouse.y = - ( event.clientY / window.height ) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);

        // TODO 
        const distFromWhole = (pt) => Math.abs(Math.abs(pt.x) - Math.abs(Math.round(pt.x)));
        var xp = worldCoordinateHelper.getIntersections(e.clientX, e.clientY, scene.children)
                .filter(val => Math.round(val.point.x) !== val.point.x)
                .reduceRight((prevVal, currVal) =>  distFromWhole(prevVal.point) < distFromWhole(currVal.point) ? prevVal : currVal);

        xp = Math.round(xp.point.x);
        axis = buildAxis( new THREE.Vector3( xp, -200, 0 ), new THREE.Vector3( xp, 200, 0 ), 0xFF0000, false );

        scene.add(axis);
        renderer.render(scene, camera);
    });

    document.addEventListener('mousedown', e => {
        const button = e.which || e.button;
        const isLeft = button == 1;
        
        const objects = worldCoordinateHelper.getIntersections(e.clientX, e.clientY, scene.children);
        var o = [];
        if (objects.length>0) {
            for (var i in objects) {
                if (objects[i].object.userData.verticeIndex) {
                    o.push(objects[i].object.userData.verticeIndex);
                }
            }
            o = o.length>0 ? o[0] : -1;
        } else {
            o = -1;
        } 

        activeCell = (o>=0) ? true : false;

        for(var i in scene.children) {
            if (scene.children[i].userData.verticeIndex === o) {
                scene.children[i].material.color.setHex(0x78F9F6);
                //scene.children[i].scale.set(2,2,2);
            }
        }

        /*if (isLeft) {
            if (intersections.length > 0) {
                outline = getWireframe(intersections[0].object.geometry, { color: 0xff0000 });
                scene.add(outline);    
            } else if (outline) {
                scene.remove(outline);
            }
            
            console.log(intersections);
            //intersections
        }*/
    });

    var userDataIter = 0;
    function add(object) {
        object.userData.verticeIndex = userDataIter++;
        scene.add(object);
    }

    //controls.panSpeed = 0.1;
    controls.noRotate = true;
    controls.noZoom = false;
    controls.zoomSpeed = 3;
    controls.noPan = false;
    controls.staticMoving = true;

    var size = viewportMaxAxis * 2;
    var divisions = viewportMaxAxis * 2;
    gridHelper = new NumeratedGridHelper(size, divisions); // new THREE.GridHelper( size, divisions );
    gridHelper.rotation.x = Math.PI / 2;
    add( gridHelper );

    add( getTriangleWireframe( 
        new THREE.Vector2(1, 1),
        new THREE.Vector2(1, 5),
        new THREE.Vector2(5, 1)
    ));

    add( getSquareWireframe( 
        new THREE.Vector2(0, 0),
        new THREE.Vector2(-4, -4),
        new THREE.Vector2(-5, 5),
        new THREE.Vector2(-2, 0)
    ));

    add( getLine(
        new THREE.Vector2(0, 0),
        new THREE.Vector2(0, 10),
        { color: 0xffff00, linewidth: 2 }
    ));

    const l = getLine(
        new THREE.Vector2(0, 0),
        new THREE.Vector2(0, -10),
        { color: 0xffff00, linewidth: 2 }
    );

    function outline(obj) {
        var edges = new THREE.EdgesGeometry(obj, 0x0000ff);
        edges.material.linewidth = 2;

        return edges;
    }

    add(l);
    add(getWireframe(l.geometry, { color: 0xff0000, linewidth: 2 }));

    pt = getSquarePoint(
        new THREE.Vector2(2, -2),
        { color: 0x00ff00 }
    );

    add(pt);

    // scene.add( buildAxes(window.innerWidth) );

    function samplePoint() {
        var geom = new THREE.Geometry(),
            mat = new THREE.PointsMaterial({ color: 0x000000, size: 1 });
        geom.vertices.push( new THREE.Vector3(0, 0, 0));

        var pt = new THREE.Points(geom, mat);
        return pt;
    }

    //scene.add(pt);

    function animate() {
        requestAnimationFrame( animate );

        if (canUpdate) {
            controls.update();
        }

        renderer.render( scene, camera );
    }

    animate();
</script>

</body>

</html>

