<html>

<head>
<title>WebGL Up And Running &mdash; Example 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script> <!-- Get the latest version of the Three.js library. -->
<script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
<script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/OrthographicTrackballControls.js"></script>

</head>

<body>
    
<script type="text/javascript">
    function buildAxis( src, dst, colorHex, dashed ) {
        var geom = new THREE.Geometry(),
            mat;

        if(dashed) {
                mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
        } else {
                mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
        }

        geom.vertices.push( src.clone() );
        geom.vertices.push( dst.clone() );
        geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

        var axis = new THREE.Line( geom, mat, THREE.LineSegments );

        return axis;
    }

    function buildAxes( length ) {
        var axes = new THREE.Object3D();

        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    
        return axes;
    }

    var canUpdate = true;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    document.body.appendChild(renderer.domElement);
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( 0xeeeeee, 1.0 );

    const scene = new THREE.Scene();
    //var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const camera = new THREE.OrthographicCamera(-window.innerWidth / 50, 
                                                window.innerWidth / 50, 
                                                -window.innerHeight / 50,
                                                window.innerHeight / 50); // */ new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );
    camera.position.set( 0, 0, 20 );
    var lookVector = new THREE.Vector3( 0, 0, 0 );
    camera.lookAt( lookVector );

    const controls = new THREE.OrthographicTrackballControls( camera );
    /*document.addEventListener('mouseup', (e) => {
        const incr = 5;
        const current = camera.position;
        camera.position.set(current.x + incr, current.y, current.z);

        lookVector.x += incr;
        camera.lookAt(lookVector);
    }, false);*/

    controls.rotateSpeed = 2.0;
    //controls.noRotate = true;

    //controls.zoomSpeed = 1.5;
    controls.panSpeed = 0.1;

    controls.noZoom = false;
    controls.noPan = false;
    controls.staticMoving = true;

    //controls.dynamicDampingFactor = 0.3;
    var size = 30;
    var divisions = 30;
    var gridHelper = new THREE.GridHelper( size, divisions );
    gridHelper.rotation.x = Math.PI / 2;
    scene.add( gridHelper );

    // scene.add( buildAxes(window.innerWidth) );

    function samplePoint() {
        var geom = new THREE.Geometry(),
            mat = new THREE.PointsMaterial({ color: 0x000000, size: 1 });
        geom.vertices.push( new THREE.Vector3(0, 0, 0));

        var pt = new THREE.Points(geom, mat);
        return pt;
    }

    //scene.add(pt);

    function animate() {
        requestAnimationFrame( animate );

        if (canUpdate) {
            controls.update();
        }

        renderer.render( scene, camera );
    }

    animate();
</script>

</body>

</html>

