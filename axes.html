<html>

<head>
<title>WebGL Up And Running &mdash; Example 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script> <!-- Get the latest version of the Three.js library. -->
<script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
<script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/OrthographicTrackballControls.js"></script>

<script src="./helpers.js"></script>

</head>

<body>
    
<script type="text/javascript">
    function buildAxis( src, dst, colorHex, dashed ) {
        var geom = new THREE.Geometry(),
            mat;

        if(dashed) {
                mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
        } else {
                mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
        }

        geom.vertices.push( src.clone() );
        geom.vertices.push( dst.clone() );
        geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

        var axis = new THREE.Line( geom, mat, THREE.LineSegments );

        return axis;
    }

    function buildAxes( length ) {
        var axes = new THREE.Object3D();

        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    
        return axes;
    }

    function NumeratedGridHelper( size, divisions, color1, color2 ) {

        size = size || 10;
        divisions = divisions || 10;
        color1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );
        color2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );

        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;

        var vertices = [], colors = [];

        for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

            vertices.push( - halfSize, 0, k, halfSize, 0, k );
            vertices.push( k, 0, - halfSize, k, 0, halfSize );

            var color = i === center ? color1 : color2;

            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            
        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

        var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

        THREE.LineSegments.call( this, geometry, material );
    }

    NumeratedGridHelper.prototype = Object.create( THREE.LineSegments.prototype );
    NumeratedGridHelper.prototype.constructor = NumeratedGridHelper;


    var canUpdate = true;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    document.body.appendChild(renderer.domElement);
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( 0xeeeeee, 1.0 );

    const scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    /*const camera = new THREE.OrthographicCamera(-window.innerWidth / 50, 
                                                window.innerWidth / 50, 
                                                -window.innerHeight / 50,
                                                window.innerHeight / 50); // */ //new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );
    camera.position.set( 0, 0, 20 );
    var lookVector = new THREE.Vector3( 0, 0, 0 );
    camera.lookAt( lookVector );

    const controls = new THREE.OrthographicTrackballControls( camera );
    var axis;
    var gridHelper;

    document.addEventListener('mouseup', (e) => {
        console.log(e);
        // sad treba transformation matrix ili nešto na position
        // da se dobiju realne koordinate

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0);
        const window = renderer.context.canvas;

        mouse.x = ( event.clientX / window.width ) * 2 - 1;
        mouse.y = - ( event.clientY / window.height ) * 2 + 1;
        raycaster.setFromCamera(mouse.clone(), camera);

        console.log(raycaster.ray);
        const intersect = raycaster.intersectObject(gridHelper);
        //axis = buildAxis( new THREE.Vector3( raycaster.ray.origin.x, -200, 0 ), new THREE.Vector3( raycaster.ray.origin.x, 200, 0 ), 0xFF0000, false );

        // pokuša napravit intersection sve djece predanog objekta. 
        // vj bi trebalo provjerit je li integer 
        const xp = intersect[0].point.x;
        axis = buildAxis( new THREE.Vector3( xp, -200, 0 ), new THREE.Vector3( xp, 200, 0 ), 0xFF0000, false );

        scene.add(axis);
        renderer.render(scene, camera);
    }, false);

    document.addEventListener('mousemove', (e) => {
        //if(axis)
            //scene.remove(axis);
        
    });

    controls.panSpeed = 0.1;
    controls.noRotate = true;
    controls.noZoom = false;
    controls.zoomSpeed = 1.2;
    controls.noPan = false;
    controls.staticMoving = true;

    var size = 30;
    var divisions = 30;
    gridHelper = new NumeratedGridHelper(size, divisions); // new THREE.GridHelper( size, divisions );
    gridHelper.rotation.x = Math.PI / 2;
    scene.add( gridHelper );

    // scene.add( buildAxes(window.innerWidth) );

    function samplePoint() {
        var geom = new THREE.Geometry(),
            mat = new THREE.PointsMaterial({ color: 0x000000, size: 1 });
        geom.vertices.push( new THREE.Vector3(0, 0, 0));

        var pt = new THREE.Points(geom, mat);
        return pt;
    }

    //scene.add(pt);

    function animate() {
        requestAnimationFrame( animate );

        if (canUpdate) {
            controls.update();
        }

        renderer.render( scene, camera );
    }

    animate();
</script>

</body>

</html>

